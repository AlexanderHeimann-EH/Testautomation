namespace Spark.Parser.Markup
{
    using Spark.Parser;
    using Spark.Parser.Code;
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public class MarkupGrammar : CodeGrammar
    {
        public ParseAction<Node> AnyNode;
        public ParseAction<AttributeNode> Attribute;
        public ParseAction<ExpressionNode> Code;
        public ParseAction<CommentNode> Comment;
        public ParseAction<DoctypeNode> DoctypeDecl;
        public ParseAction<ElementNode> Element;
        public ParseAction<EndElementNode> EndElement;
        public ParseAction<EntityNode> EntityRef;
        public ParseAction<TextNode> EscapedCode;
        public ParseAction<SpecialNode> Ignore;
        public ParseAction<IList<Node>> Nodes;
        public ParseAction<ProcessingInstructionNode> ProcessingInstruction;
        public ParseAction<StatementNode> Statement;
        public ParseAction<TextNode> Text;
        public ParseAction<IList<char>> Whitespace;
        public ParseAction<XMLDeclNode> XMLDecl;

        public MarkupGrammar() : this(ParserSettings.DefaultBehavior)
        {
        }

        public MarkupGrammar(IParserSettings settings)
        {
            Func<Chain<Chain<string, Snippets>, char>, ExpressionNode> builder = null;
            Func<Chain<Chain<string, Snippets>, char>, ExpressionNode> func2 = null;
            ParseAction<char> parser = CharGrammar.Ch('\'');
            ParseAction<char> action2 = CharGrammar.Ch('"');
            ParseAction<char> action3 = CharGrammar.Ch('<');
            ParseAction<char> action4 = CharGrammar.Ch('>');
            CharGrammar.ChNot('<');
            ParseAction<char> parse = CharGrammar.Ch(new Func<char, bool>(char.IsLetterOrDigit)).Or<char>(CharGrammar.Ch(new char[] { '.', '-', '_', ':' }));
            ParseAction<string> action6 = CharGrammar.Ch(new Func<char, bool>(char.IsLetter)).Or<char>(CharGrammar.Ch(new char[] { '_', ':' })).And<char, IList<char>>(Grammar.Rep<char>(parse)).Build<Chain<char, IList<char>>, string>(hit => hit.Left + new string(hit.Down.ToArray<char>()));
            Grammar.Rep1<char>(parse).Build<IList<char>, string>(hit => new string(hit.ToArray<char>()));
            this.Whitespace = Grammar.Rep1<char>(CharGrammar.Ch(new Func<char, bool>(char.IsWhiteSpace)));
            ParseAction<Chain<Chain<IList<char>, char>, IList<char>>> action7 = Grammar.Opt<IList<char>>(this.Whitespace).And<IList<char>, char>(CharGrammar.Ch('=')).And<Chain<IList<char>, char>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace));
            ParseAction<StatementNode> action8 = base.Statement1.Build<IList<Snippet>, StatementNode>(hit => new StatementNode(hit)).Paint<StatementNode, Node>();
            string match = string.IsNullOrEmpty(settings.StatementMarker) ? "#" : settings.StatementMarker;
            ParseAction<StatementNode> action9 = Grammar.Opt<char>(CharGrammar.Ch('\r')).And<char, char>(CharGrammar.Ch('\n').Or<char>(CharGrammar.ChSTX())).And<Chain<char, char>, IList<char>>(Grammar.Rep<char>(CharGrammar.Ch(new char[] { ' ', '\t' }))).And<Chain<Chain<char, char>, IList<char>>, string>(CodeGrammar.TkCode<string>(CharGrammar.Ch(match))).And<Chain<Chain<Chain<char, char>, IList<char>>, string>, StatementNode>(action8).IfNext<Chain<Chain<Chain<Chain<char, char>, IList<char>>, string>, StatementNode>, char>(CharGrammar.Ch(new char[] { '\r', '\n' }).Or<char>(CharGrammar.ChETX())).Build<Chain<Chain<Chain<Chain<char, char>, IList<char>>, string>, StatementNode>, StatementNode>(hit => hit.Down);
            ParseAction<StatementNode> action10 = base.Statement2.Build<IList<Snippet>, StatementNode>(hit => new StatementNode(hit)).Paint<StatementNode, Node>();
            ParseAction<StatementNode> action11 = CodeGrammar.TkAspxCode<string>(CharGrammar.Ch("<%")).NotNext<string, char>(CharGrammar.Ch('=')).And<string, StatementNode>(action10).And<Chain<string, StatementNode>, string>(CodeGrammar.TkAspxCode<string>(CharGrammar.Ch("%>"))).Build<Chain<Chain<string, StatementNode>, string>, StatementNode>(hit => hit.Left.Down);
            this.Statement = action9.Or<StatementNode>(action11);
            ParseAction<TextNode> action12 = CodeGrammar.TkCode<string>(CharGrammar.Ch(@"\${").Or<string>(CharGrammar.Ch("$${")).Or<string>(CharGrammar.Ch("`${"))).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, TextNode>(hit => new TextNode("${" + hit.Left.Down + "}"));
            ParseAction<TextNode> action13 = CodeGrammar.TkCode<string>(CharGrammar.Ch(@"\!{").Or<string>(CharGrammar.Ch("!!{")).Or<string>(CharGrammar.Ch("`!{"))).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, TextNode>(hit => new TextNode("!{" + hit.Left.Down + "}"));
            ParseAction<TextNode> action14 = CodeGrammar.TkCode<string>(CharGrammar.Ch(@"\$!{").Or<string>(CharGrammar.Ch("$$!{")).Or<string>(CharGrammar.Ch("`$!{"))).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, TextNode>(hit => new TextNode("$!{" + hit.Left.Down + "}"));
            this.EscapedCode = action12.Or<TextNode>(action13).Or<TextNode>(action14);
            if (builder == null)
            {
                builder = hit => new ExpressionNode(hit.Left.Down) { AutomaticEncoding = settings.AutomaticEncoding };
            }
            ParseAction<ExpressionNode> action15 = CodeGrammar.TkCode<string>(CharGrammar.Ch("${")).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, ExpressionNode>(builder);
            ParseAction<ExpressionNode> action16 = CodeGrammar.TkAspxCode<string>(CharGrammar.Ch("<%")).And<string, char>(CodeGrammar.TkAttDelim<char>(CharGrammar.Ch('='))).And<Chain<string, char>, Snippets>(base.Expression).And<Chain<Chain<string, char>, Snippets>, string>(CodeGrammar.TkAspxCode<string>(CharGrammar.Ch("%>"))).Build<Chain<Chain<Chain<string, char>, Snippets>, string>, ExpressionNode>(hit => new ExpressionNode(hit.Left.Down));
            if (func2 == null)
            {
                func2 = hit => new ExpressionNode(hit.Left.Down) { SilentNulls = true, AutomaticEncoding = settings.AutomaticEncoding };
            }
            ParseAction<ExpressionNode> action17 = CodeGrammar.TkCode<string>(CharGrammar.Ch("$!{")).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, ExpressionNode>(func2);
            ParseAction<ExpressionNode> action18 = CodeGrammar.TkCode<string>(CharGrammar.Ch("!{")).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, ExpressionNode>(hit => new ExpressionNode(hit.Left.Down));
            this.Code = action15.Or<ExpressionNode>(action16).Or<ExpressionNode>(action17).Or<ExpressionNode>(action18);
            ParseAction<ConditionNode> action19 = CodeGrammar.TkCode<string>(CharGrammar.Ch("?{")).And<string, Snippets>(base.Expression).And<Chain<string, Snippets>, char>(CodeGrammar.TkCode<char>(CharGrammar.Ch('}'))).Build<Chain<Chain<string, Snippets>, char>, ConditionNode>(hit => new ConditionNode(hit.Left.Down));
            ParseAction<Node> action20 = CharGrammar.Ch('<').Build<char, Node>(hit => new TextNode("<"));
            this.EntityRef = CodeGrammar.TkEntity<Chain<Chain<char, string>, char>>(CharGrammar.Ch('&').And<char, string>(action6).And<Chain<char, string>, char>(CharGrammar.Ch(';'))).Build<Chain<Chain<char, string>, char>, EntityNode>(hit => new EntityNode(hit.Left.Down));
            ParseAction<Node> action21 = this.AsNode<EntityNode>(this.EntityRef).Or<Node>(CharGrammar.Ch('&').Build<char, Node>(hit => new TextNode("&")));
            ParseAction<TextNode> action22 = CodeGrammar.TkAttVal<IList<char>>(Grammar.Rep1<char>(CharGrammar.ChNot(new char[] { '<', '&', '\'' }).Unless<char, ExpressionNode>(this.Code).Unless<char, ConditionNode>(action19))).Build<IList<char>, TextNode>(hit => new TextNode(hit));
            ParseAction<Chain<Chain<char, IList<Node>>, char>> action23 = CodeGrammar.TkAttQuo<char>(parser).And<char, IList<Node>>(Grammar.Rep<Node>(this.AsNode<TextNode>(action22).Or<Node>(action21).Or<Node>(this.AsNode<ExpressionNode>(this.Code)).Or<Node>(this.AsNode<ConditionNode>(action19)).Or<Node>(action20).Paint<Node>())).And<Chain<char, IList<Node>>, char>(CodeGrammar.TkAttQuo<char>(parser));
            ParseAction<TextNode> action24 = CodeGrammar.TkAttVal<IList<char>>(Grammar.Rep1<char>(CharGrammar.ChNot(new char[] { '<', '&', '"' }).Unless<char, ExpressionNode>(this.Code).Unless<char, ConditionNode>(action19))).Build<IList<char>, TextNode>(hit => new TextNode(hit));
            ParseAction<Chain<Chain<char, IList<Node>>, char>> action25 = CodeGrammar.TkAttQuo<char>(action2).And<char, IList<Node>>(Grammar.Rep<Node>(this.AsNode<TextNode>(action24).Or<Node>(action21).Or<Node>(this.AsNode<ExpressionNode>(this.Code)).Or<Node>(this.AsNode<ConditionNode>(action19)).Or<Node>(action20).Paint<Node>())).And<Chain<char, IList<Node>>, char>(CodeGrammar.TkAttQuo<char>(action2));
            ParseAction<Chain<Chain<char, IList<Node>>, char>> action26 = action23.Or<Chain<Chain<char, IList<Node>>, char>>(action25);
            this.Attribute = CodeGrammar.TkAttNam<string>(action6).And<string, Chain<Chain<IList<char>, char>, IList<char>>>(CodeGrammar.TkAttDelim<Chain<Chain<IList<char>, char>, IList<char>>>(action7)).And<Chain<string, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, IList<Node>>, char>>(action26).Build<Chain<Chain<string, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, IList<Node>>, char>>, AttributeNode>(hit => new AttributeNode(hit.Left.Left, hit.Down.Down, hit.Down.Left.Down)).Paint<AttributeNode, Node>();
            this.Ignore = Grammar.Opt<Chain<string, string>>(CharGrammar.Ch("\r\n").Or<string>(CharGrammar.Ch("\n")).And<string, string>(CharGrammar.StringOf(CharGrammar.Ch(new Func<char, bool>(char.IsWhiteSpace)).Unless<char, char>(CharGrammar.Ch(new char[] { '\r', '\n' }))))).And<Chain<string, string>, char>(CodeGrammar.TkTagDelim<char>(action3)).And<Chain<Chain<string, string>, char>, string>(CodeGrammar.TkEleNam<string>(CharGrammar.Ch("ignore"))).And<Chain<Chain<Chain<string, string>, char>, string>, char>(CodeGrammar.TkTagDelim<char>(action4)).And<Chain<Chain<Chain<Chain<string, string>, char>, string>, char>, IList<char>>(Grammar.Rep<char>(CharGrammar.ChNot('<').Or<char>(action3.IfNext<char, string>(CharGrammar.ChNot("/ignore>"))))).And<Chain<Chain<Chain<Chain<Chain<string, string>, char>, string>, char>, IList<char>>, string>(CharGrammar.Ch("</ignore>")).Build<Chain<Chain<Chain<Chain<Chain<Chain<string, string>, char>, string>, char>, IList<char>>, string>, SpecialNode>(hit => new SpecialNode(new ElementNode(hit.Left.Left.Left.Down, new List<AttributeNode>(), false, (hit.Left.Left.Left.Left.Left == null) ? string.Empty : (hit.Left.Left.Left.Left.Left.Left + hit.Left.Left.Left.Left.Left.Down))) { Body = new List<Node> { new TextNode(hit.Left.Down) } });
            this.Element = Grammar.Opt<Chain<string, string>>(CharGrammar.Ch("\r\n").Or<string>(CharGrammar.Ch("\n")).And<string, string>(CharGrammar.StringOf(CharGrammar.Ch(new Func<char, bool>(char.IsWhiteSpace)).Unless<char, char>(CharGrammar.Ch(new char[] { '\r', '\n' }))))).And<Chain<string, string>, char>(CodeGrammar.TkTagDelim<char>(action3)).And<Chain<Chain<string, string>, char>, string>(CodeGrammar.TkEleNam<string>(action6)).And<Chain<Chain<Chain<string, string>, char>, string>, IList<AttributeNode>>(Grammar.Rep<AttributeNode>(this.Whitespace.And<IList<char>, AttributeNode>(this.Attribute).Down<IList<char>, AttributeNode>())).And<Chain<Chain<Chain<Chain<string, string>, char>, string>, IList<AttributeNode>>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace)).And<Chain<Chain<Chain<Chain<Chain<string, string>, char>, string>, IList<AttributeNode>>, IList<char>>, char>(Grammar.Opt<char>(CodeGrammar.TkTagDelim<char>(CharGrammar.Ch('/')))).And<Chain<Chain<Chain<Chain<Chain<Chain<string, string>, char>, string>, IList<AttributeNode>>, IList<char>>, char>, char>(CodeGrammar.TkTagDelim<char>(action4)).Build<Chain<Chain<Chain<Chain<Chain<Chain<Chain<string, string>, char>, string>, IList<AttributeNode>>, IList<char>>, char>, char>, ElementNode>(hit => new ElementNode(hit.Left.Left.Left.Left.Down, hit.Left.Left.Left.Down, hit.Left.Down != '\0', (hit.Left.Left.Left.Left.Left.Left == null) ? string.Empty : (hit.Left.Left.Left.Left.Left.Left.Left + hit.Left.Left.Left.Left.Left.Left.Down)));
            this.EndElement = Grammar.Opt<Chain<string, string>>(CharGrammar.Ch("\r\n").Or<string>(CharGrammar.Ch("\n")).And<string, string>(CharGrammar.StringOf(CharGrammar.Ch(new Func<char, bool>(char.IsWhiteSpace)).Unless<char, char>(CharGrammar.Ch(new char[] { '\r', '\n' }))))).And<Chain<string, string>, Chain<char, char>>(CodeGrammar.TkTagDelim<Chain<char, char>>(action3.And<char, char>(CharGrammar.Ch('/')))).And<Chain<Chain<string, string>, Chain<char, char>>, string>(CodeGrammar.TkEleNam<string>(action6)).And<Chain<Chain<Chain<string, string>, Chain<char, char>>, string>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace)).And<Chain<Chain<Chain<Chain<string, string>, Chain<char, char>>, string>, IList<char>>, char>(CodeGrammar.TkTagDelim<char>(action4)).Build<Chain<Chain<Chain<Chain<Chain<string, string>, Chain<char, char>>, string>, IList<char>>, char>, EndElementNode>(hit => new EndElementNode(hit.Left.Left.Down, (hit.Left.Left.Left.Left == null) ? string.Empty : (hit.Left.Left.Left.Left.Left + hit.Left.Left.Left.Left.Down)));
            this.Text = Grammar.Rep1<char>(CharGrammar.ChNot(new char[] { '&', '<' }).Unless<char, StatementNode>(this.Statement).Unless<char, ExpressionNode>(this.Code).Unless<char, TextNode>(this.EscapedCode).Unless<char, SpecialNode>(this.Ignore).Unless<char, ElementNode>(this.Element).Unless<char, EndElementNode>(this.EndElement)).Build<IList<char>, TextNode>(hit => new TextNode(hit));
            this.Comment = CodeGrammar.TkComm<Chain<Chain<string, IList<char>>, string>>(CharGrammar.Ch("<!--").And<string, IList<char>>(Grammar.Rep<char>(CharGrammar.ChNot('-').Or<char>(CharGrammar.Ch('-').IfNext<char, char>(CharGrammar.ChNot('-'))))).And<Chain<string, IList<char>>, string>(CharGrammar.Ch("-->"))).Build<Chain<Chain<string, IList<char>>, string>, CommentNode>(hit => new CommentNode(hit.Left.Down));
            ParseAction<string> action27 = action2.And<char, IList<char>>(Grammar.Rep<char>(CharGrammar.ChNot('"'))).And<Chain<char, IList<char>>, char>(action2).Or<Chain<Chain<char, IList<char>>, char>>(parser.And<char, IList<char>>(Grammar.Rep<char>(CharGrammar.ChNot('\''))).And<Chain<char, IList<char>>, char>(parser)).Build<Chain<Chain<char, IList<char>>, char>, string>(hit => new string(hit.Left.Down.ToArray<char>()));
            ParseAction<char> action28 = CharGrammar.Ch(new Func<char, bool>(char.IsLetterOrDigit)).Or<char>(CharGrammar.Ch(" \r\n-()+,./:=?;!*#@$_%".ToArray<char>()));
            ParseAction<char> action29 = action28.Or<char>(parser);
            ParseAction<string> action30 = action2.And<char, IList<char>>(Grammar.Rep<char>(action29)).And<Chain<char, IList<char>>, char>(action2).Or<Chain<Chain<char, IList<char>>, char>>(parser.And<char, IList<char>>(Grammar.Rep<char>(action28)).And<Chain<char, IList<char>>, char>(parser)).Build<Chain<Chain<char, IList<char>>, char>, string>(hit => new string(hit.Left.Down.ToArray<char>()));
            ParseAction<ExternalIdInfo> action31 = CharGrammar.Ch("SYSTEM").And<string, IList<char>>(this.Whitespace).And<Chain<string, IList<char>>, string>(action27).Build<Chain<Chain<string, IList<char>>, string>, ExternalIdInfo>(hit => new ExternalIdInfo { ExternalIdType = hit.Left.Left, SystemId = hit.Down });
            ParseAction<ExternalIdInfo> action32 = CharGrammar.Ch("PUBLIC").And<string, IList<char>>(this.Whitespace).And<Chain<string, IList<char>>, string>(action30).And<Chain<Chain<string, IList<char>>, string>, IList<char>>(this.Whitespace).And<Chain<Chain<Chain<string, IList<char>>, string>, IList<char>>, string>(action27).Build<Chain<Chain<Chain<Chain<string, IList<char>>, string>, IList<char>>, string>, ExternalIdInfo>(hit => new ExternalIdInfo { ExternalIdType = hit.Left.Left.Left.Left, PublicId = hit.Left.Left.Down, SystemId = hit.Down });
            ParseAction<ExternalIdInfo> action33 = action31.Or<ExternalIdInfo>(action32);
            this.DoctypeDecl = CharGrammar.Ch("<!DOCTYPE").And<string, IList<char>>(this.Whitespace).And<Chain<string, IList<char>>, string>(action6).And<Chain<Chain<string, IList<char>>, string>, ExternalIdInfo>(Grammar.Opt<ExternalIdInfo>(this.Whitespace.And<IList<char>, ExternalIdInfo>(action33).Down<IList<char>, ExternalIdInfo>())).And<Chain<Chain<Chain<string, IList<char>>, string>, ExternalIdInfo>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace)).And<Chain<Chain<Chain<Chain<string, IList<char>>, string>, ExternalIdInfo>, IList<char>>, char>(CharGrammar.Ch('>')).Build<Chain<Chain<Chain<Chain<Chain<string, IList<char>>, string>, ExternalIdInfo>, IList<char>>, char>, DoctypeNode>(hit => new DoctypeNode { Name = hit.Left.Left.Left.Down, ExternalId = hit.Left.Left.Down });
            ParseAction<string> action34 = CharGrammar.Ch("1.0");
            ParseAction<Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>> action35 = this.Whitespace.And<IList<char>, string>(CharGrammar.Ch("version")).And<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>(action7).And<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>(parser.And<char, string>(action34).And<Chain<char, string>, char>(parser).Or<Chain<Chain<char, string>, char>>(action2.And<char, string>(action34).And<Chain<char, string>, char>(action2)));
            ParseAction<string> action36 = CharGrammar.Ch(new Func<char, bool>(char.IsLetter)).And<char, IList<char>>(Grammar.Rep<char>(CharGrammar.Ch(new Func<char, bool>(char.IsLetterOrDigit)).Or<char>(CharGrammar.Ch(new char[] { '.', '_', '-' })))).Build<Chain<char, IList<char>>, string>(hit => hit.Left + new string(hit.Down.ToArray<char>()));
            ParseAction<string> action37 = this.Whitespace.And<IList<char>, string>(CharGrammar.Ch("encoding")).And<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>(action7).And<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>(parser.And<char, string>(action36).And<Chain<char, string>, char>(parser).Or<Chain<Chain<char, string>, char>>(action2.And<char, string>(action36).And<Chain<char, string>, char>(action2))).Build<Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>, string>(hit => hit.Down.Left.Down);
            ParseAction<string> action38 = this.Whitespace.And<IList<char>, string>(CharGrammar.Ch("standalone")).And<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>(action7).And<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>(parser.And<char, string>(CharGrammar.Ch("yes").Or<string>(CharGrammar.Ch("no"))).And<Chain<char, string>, char>(parser).Or<Chain<Chain<char, string>, char>>(action2.And<char, string>(CharGrammar.Ch("yes").Or<string>(CharGrammar.Ch("no"))).And<Chain<char, string>, char>(action2))).Build<Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>, string>(hit => hit.Down.Left.Down);
            this.XMLDecl = CharGrammar.Ch("<?xml").And<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>(action35).And<Chain<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>, string>(Grammar.Opt<string>(action37)).And<Chain<Chain<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>, string>, string>(Grammar.Opt<string>(action38)).And<Chain<Chain<Chain<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>, string>, string>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace)).And<Chain<Chain<Chain<Chain<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>, string>, string>, IList<char>>, string>(CharGrammar.Ch("?>")).Build<Chain<Chain<Chain<Chain<Chain<string, Chain<Chain<Chain<IList<char>, string>, Chain<Chain<IList<char>, char>, IList<char>>>, Chain<Chain<char, string>, char>>>, string>, string>, IList<char>>, string>, XMLDeclNode>(hit => new XMLDeclNode { Encoding = hit.Left.Left.Left.Down, Standalone = hit.Left.Left.Down });
            ParseAction<string> action39 = action6.Unless<string, Chain<Chain<char, char>, char>>(CharGrammar.Ch(new char[] { 'X', 'x' }).And<char, char>(CharGrammar.Ch(new char[] { 'M', 'm' })).And<Chain<char, char>, char>(CharGrammar.Ch(new char[] { 'L', 'l' })));
            this.ProcessingInstruction = CharGrammar.Ch("<?").And<string, string>(action39).And<Chain<string, string>, IList<char>>(Grammar.Opt<IList<char>>(this.Whitespace)).And<Chain<Chain<string, string>, IList<char>>, IList<char>>(Grammar.Rep<char>(CharGrammar.Ch((Func<char, bool>) (ch => true)).Unless<char, string>(CharGrammar.Ch("?>")))).And<Chain<Chain<Chain<string, string>, IList<char>>, IList<char>>, string>(CharGrammar.Ch("?>")).Build<Chain<Chain<Chain<Chain<string, string>, IList<char>>, IList<char>>, string>, ProcessingInstructionNode>(hit => new ProcessingInstructionNode { Name = hit.Left.Left.Left.Down, Body = new string(hit.Left.Down.ToArray<char>()) });
            this.AnyNode = this.AsNode<SpecialNode>(this.Ignore).Paint<Node>().Or<Node>(this.AsNode<TextNode>(this.EscapedCode).Paint<Node>()).Or<Node>(this.AsNode<ElementNode>(this.Element).Paint<Node>()).Or<Node>(this.AsNode<EndElementNode>(this.EndElement).Paint<Node>()).Or<Node>(this.AsNode<TextNode>(this.Text).Paint<Node>()).Or<Node>(action21.Paint<Node>()).Or<Node>(this.AsNode<StatementNode>(this.Statement)).Or<Node>(this.AsNode<ExpressionNode>(this.Code).Paint<Node>()).Or<Node>(this.AsNode<DoctypeNode>(this.DoctypeDecl).Paint<Node>()).Or<Node>(this.AsNode<CommentNode>(this.Comment).Paint<Node>()).Or<Node>(this.AsNode<XMLDeclNode>(this.XMLDecl).Paint<Node>()).Or<Node>(this.AsNode<ProcessingInstructionNode>(this.ProcessingInstruction).Paint<Node>()).Or<Node>(this.AsNode<Node>(action20).Paint<Node>());
            this.Nodes = Grammar.Rep<Node>(this.AnyNode);
        }

        public ParseAction<Node> AsNode<TValue>(ParseAction<TValue> parser) where TValue: Node
        {
            return delegate (Position input) {
                ParseResult<TValue> result = parser(input);
                if (result == null)
                {
                    return null;
                }
                return new ParseResult<Node>(result.Rest, result.Value);
            };
        }
    }
}

