{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}{\f1\fnil\fprq1\fcharset0 Courier New;}{\f2\fswiss\fprq2\fcharset0 Arial;}}
{\colortbl ;\red43\green145\blue175;\red0\green0\blue255;\red0\green128\blue0;\red163\green21\blue21;\red128\green128\blue128;\red0\green0\blue0;}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\b\f0\fs24 Loading and Unloading Unloading a .Net Assemblies at Runtime.\par
\par
Introduction:\b0\fs20\par
\tab\par
\tab Basicaly In my company I am into .Net 3.0 development. One of my work assignments included some R&D upon changing workflows at runtime. We were targeting at loading a workflow rules at runtime itself. At the time we had the Workflow information and rules combined in a separate .Net Assembly. But it is referenced into the application as a reference at the design time itself. A Work flow tool (from Mcrosoft itself I think) provides the facility of creation and modification of workflow at runtime itself. We were expecting the workflow data will be provided as a .Net assembly and assembly should load into the application just like opening a word file. \par
\tab\par
\tab As the part I started thinking about loading and unloading an assembly without stopping the application. First thing I looked as everyone does was looking into web for example applications. But alas! to my bad luck (or it is for my good sake!)  there was no sample available in relation to this topic and where ever I searched I found references saying that it is a very difficult thing and every one is recommending not doing it. But upon our requirement this feature is a critical component as without that the complete task will be left unusable. So I directly jumped into MSDN and started with Appdomains. Because I had already got some hands on reflection and appdomains finding what to do was not that much difficult. After completing the requirement, I started thinking about sharing the work I had done which ended up in creating this article.\par
\par
\b\fs24 Background:\par
\b0\fs20\par
\tab This Article contains topics related to Appdomains and some basics of  Reflection. If you are looking for some articles in relation with any of these subjects then this article may be appropriate to you.\par
\tab 1)\tab Basic Usage of Appdomains.\par
\tab 2)\tab Unloading An Assembly without unloading the application.\par
\tab 3)\tab Loading of Assemblies at runtime \par
\tab 4)\tab Runtime Versioning of assemblies.\par
\tab 5)\tab Calling any member from an assembly with reflection.\par
 \tab 6)\tab Cross Appdomain Communication.\par
\tab 7)\tab Loading and Unloading of second Appdomain.\par
\tab 8)\tab Using a .Net Assembly without locking it's Assembly file by windows.\par
\tab 9)\tab A basic sample to structured coding flow.\par
\par
\b\fs24 Using the code:\par
\b0\fs20\tab When I started thinking about sharing the code into Codeproject I found that my code will be too complex and bulky. it contained a lot of additional functionalities that was related to the .Net 3.0 which are out topic. So I decided to create a new Windows Aplication based upon .Net 2.0 and implement all the required featues in that.\par
\par
\tab As the part I created a new Windows application and designed the basic UI to decide upon the functionalities and workflow of the sample. After that I continued upon deciding the class structure and then into final coding. For your convenience I am including the step by step progress of my work.\par
\par
I am assuming that the reader is an experienced developer with thoughhands on experience in \par
\par
\b Step 1: \b0 Creation of the Basic UI.\par
\par
\tab Create a new Windows Application and name it "Code Project - Unload .Net Assembly".\par
\tab Take the project properties and set the default namespace to "\f1 MySpace".\par
\f2\tab Create a UI as per the picture below. During design kindly take a note on the baisc UI control names that is referenced in the application.\par
\f1\tab\par
\ul Control\ulnone\tab\tab\tab\ul Type\ulnone\tab\tab\tab\tab\ul Text\ulnone\tab\tab\tab\tab\tab\tab\ul Additional Settings\ulnone\par
\par
radioAssembly1\tab\tab RadioButton\tab\tab\tab Load Assembly V 1.0\par
radioAssembly2\tab\tab RadioButton\tab\tab\tab Load Assembly V 2.0\par
lblCurrentAssembly\tab Label\tab\tab\tab\tab Current Assembly\par
lblCurrentAppDomain\tab Label\tab\tab\tab\tab Current Appdomain\par
lblMainAppDomian\tab\tab TextBox\tab\tab\tab Default Appdomain\tab\tab\tab\tab ReadOnly=true,BorderStyle=None\par
txtReverseData\tab\tab TextBox\tab\tab\tab String Data to be inversed\par
txtReturnedData\tab\tab TextBox\tab\tab\tab (null)\par
btnCalculate\tab\tab Button\tab\tab\tab Reverse\par
btnGetValue\tab\tab\tab Button\tab\tab\tab Get Value\par
\f0 errorProvider1\tab\tab\tab ErrorProvider\f1\tab\tab\tab\f0 errorProvider1\par
\par
\b Step 2: \b0 Deciding upon Business flow. - Deciding upon Interface, Classes and it's hirarchy.\par
\par
\tab The application presents three Business scenarios for various levels of users.\par
\tab\par
\tab\b For The End User:\par
\b0\tab The program can be used to get the file version of loaded assembly and it can reverse a string passed into the assembly. When the Application starts it loads the beta version of the Dll and later on he will be able to switch into the final release of the Assembly without closing the application. The program will continue to work regardless of which Library file is loaded, but with changes in functionality according to Assembly file loaded.\par
\par
\tab\b For Leaf Level Programmer:\par
\b0\tab Upon startup Form1_Load will create an instance of proxy with default Library("version 1.0") and Domain Name. This proxy is equipped with two publicly exposed methods which is the core business logic of  the sample. One is to return the version information and other to perform an opearation from the loaded assembly. Two properties are also exposed which returns the default Appdomain and Assembly names. To the End User / Leaf Programmer these are the only details that is exposed. He is simply supposed to add reference to proxy and then create an instance and utilise it's exposed methods. He is not suppossed to know the great dynamic loading feature that is working behind.\par
\tab\par
\b\tab For Next Level Programmer:\b0\par
\tab The next step is some more complex and it is meant for programmers who wants to create an additional version of the assembly. You need to know these details if you ar eplanning to create the next version of the assembly like version 3.0.\par
\par
\tab The basic business model is defined as an Interface in the solution "BaseInterface". This conatins an interface with all the methods that is to be implemented in the assembly. Proxy and all the Assemblies is required to refer this assembly and implement it's functionalities. If you want to add any additional functionalit then you can change the interace and  recomplile the solution. Then where ever erro message is shown up implement the method accordingly to make it compatible.\par
\tab\par
\tab With regard the dynamic loading assembly two classes are used. An Assembly controller and one AppDomain controller. Assembly controller performs the file related functions like setting the default assembly, storing the Assembly type and file related informations etc. Appdomain Controller performs opeartions like loading and unloading the Appdomain, storing default Appdomain names and instance etc. \par
\tab\par
\tab I have provided the Unloading appdomain function but it is not called anywhere because GC is taking care of clearing the appdomain upon assignment of new appdomain. Even if the call to \f1 Clear the AppDomain is not made it is not going to make any difference. \f0 If you set a breakpoint in destrutor of Appdomain class u can find a delayed call which his actually called by GC that is called in an unusual way. This is actually triggered by GC at some points of it's 3 levels of Garbage Collection. This section I am leaving for an experiement for my readers.\par
\tab\tab\par
\b Step 3:\b0\tab Creation of additional projects, Class structures and control flows. - Interface, Proxy, Beta Assembly, Final Assembly.\par
\tab\par
\tab So now to proceed we have to create four more projects, all of Class Library type.\par
\tab\par
\b\tab Project  1)\tab Interface.  - \b0 Contains the Baisc Business model. which is tobe shared across the complete solution. \b\par
\b0\par
\tab\tab Name \tab\tab\tab = \tab\f1 BaseInterface\f0\par
\tab\tab set RootNamespace \tab = \tab\f1 BaseInterface\par
\tab\tab rename Class1.cs to  \cf1 IBaseInterface\cf0 .cs. Paste the code to the Code Window.\par
\par
\cf2 using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\par
\cf2 namespace\cf0  BaseInterface\par
\{\par
    \cf2 public\cf0  \cf2 interface\cf0  \cf1 IBaseInterface\par
\cf0     \{\par
        \cf2 string\cf0  ReturnBaseValue();\par
        \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value);\par
    \}\par
\}\par
\par
\tab\b\f0 Project  \f1 2)\tab Proxy. - \b0 The basic Proxy that abstracts the Leaf programmer from Dynamic Assembly loading mechanisum.\b\par
\tab\tab\par
\tab\tab\b0\f0 Name \tab\tab\tab = \tab\f1 Proxy\f0\par
\tab\tab set RootNamespace \tab = \tab\f1 MySpace\par
\tab\tab References\tab\tab = \tab Solution.BaseInterface.\par
\par
\tab Requires three class files in the project viz \b AssemblyCore.cs, AppDomainCore.cs, Proxy.cs.\b0\par
\par
\tab\b AssemblyCore.cs - \b0 Exposes\par
\tab\par
\tab\tab\cf2 public\cf0  \cf2 bool\cf0  SetDefaultAssemblyFile(\cf2 string\cf0  AssemblyFileName) - Changes the Default Assembly file\par
\tab\tab\cf2 public\cf0  \cf1 FileInfo\cf0  DefaultAssemblyFile - Returns a FileInfo Instane of Default Assembly file. \cf3\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName - Will be Always Same. Used by Application as the Assembly\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  CurrentType - Gets the Currently used Object Type.\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ActiveAssemblyFile - Get the original name of active assembly file.\par
\tab\tab\cf2 public\cf0  AssemblyCore(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  TypeName) - Construtor\par
\par
\tab To start with Paste the skeleton code into the code window.\par
\par
\cf2 using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\cf2 using\cf0  System.IO;\par
\cf2 using\cf0  System.Reflection;\par
\cf2 using\cf0  System.Windows.Forms;\par
\par
\cf2 namespace\cf0  MySpace\par
\{\par
    \cf2 internal\cf0  \cf2 class\cf0  \cf1 AssemblyCore\par
\cf0     \{\par
 \tab\tab\cf2 const\cf0  \cf2 string\cf0  OriginalAssemblyFileName = \cf4 "DefaultAssembly.dll"\cf0 ;\par
\par
\tab\tab\cf2 private\cf0  \cf2 string\cf0  _activeAssemblyFile;\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ActiveAssemblyFile\par
\tab\tab\{\par
\tab\tab\tab\cf2 get\cf0  \{ \cf2 return\cf0  _activeAssemblyFile; \}\par
\tab\tab\}\par
\tab\tab\cf2 private\cf0  \cf2 string\cf0  _CurrentType;\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  CurrentType\par
\tab\tab\{\par
\tab\tab\tab\cf2 get\cf0  \{ \cf2 return\cf0  _CurrentType; \}\par
\tab\tab\tab\cf2 set\cf0  \{ _CurrentType = \cf2 value\cf0 ; \}\par
\tab\tab\}\par
\cf5\par
\cf0\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName\par
\tab\tab\{\par
\par
\tab\tab\}\par
\par
\tab\tab\cf2 private\cf0  \cf1 FileInfo\cf0  _DefaultAssemblyFile;\par
\tab\tab\cf2 public\cf0  \cf1 FileInfo\cf0  DefaultAssemblyFile\par
\tab\tab\{\par
\tab\tab\tab\cf2 get\cf0  \{ \cf2 return\cf0  _DefaultAssemblyFile; \}\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  AssemblyCore(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  TypeName)\par
\tab\tab\{\}\par
\tab\tab\par
\tab\tab\cf2 public\cf0  \cf2 bool\cf0  SetDefaultAssemblyFile(\cf2 string\cf0  AssemblyFileName)\par
\tab\tab\{\}\par
    \}\par
\}\par
\par
\par
\tab\b AppDomainCore.cs - \b0 Exposes\par
\b\par
\b0\tab\tab\cf2 public\cf0  \cf1 AppDomain\cf0  DefaultAppDomain - Returns the Appdomain instance in use.\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAppdomainName - Returns the Friendlyname of Appdomain in use.\par
\tab\tab\cf2 public\cf0  AppDomainCore(\cf2 string\cf0  AppDoaminName) - Contructor.\par
\par
\tab Paste the skeleton code into the code window.\par
\par
\cf2 using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\par
\cf2 namespace\cf0  MySpace\par
\{\par
\tab\cf2 internal\cf0  \cf2 class\cf0  \cf1 AppDomainCore\cf0  \par
\tab\{\par
\par
\tab\tab\cf2 public\cf0  AppDomainCore(\cf2 string\cf0  AppDoaminName)\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 private\cf0  \cf1 AppDomain\cf0  _DefaultAppDomain;\par
\tab\tab\cf2 public\cf0  \cf1 AppDomain\cf0  DefaultAppDomain\par
\tab\tab\{\par
\tab\tab\tab\cf2 get\cf0  \{ \cf2 return\cf0  _DefaultAppDomain; \}\par
\tab\tab\}\par
\par
\tab\tab\cf2 private\cf0  \cf2 string\cf0  _DefaultAppdomainName;\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAppdomainName\par
\tab\tab\{\par
\tab\tab\tab\cf2 get\cf0  \{ \cf2 return\cf0  _DefaultAppdomainName; \}\par
\tab\tab\}\par
\tab\}\par
\}\par
\par
\par
\b\tab Proxy.cs - \b0 Implements the basic Business Interface \cf1 BaseInterface.IBaseInterface\cf0 .\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value) - Returns a Reversed value of the string passed.\par
\cf2\tab\tab public\cf0  \cf2 string\cf0  ReturnBaseValue() - Return a value from assembly. here it is assembly version information.\par
\tab\tab\cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName, \cf2 string\cf0  AppDomainName,\cf2 string\cf0  CurrentType) - Constructor\par
\tab\tab\cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  AppDomainName) - Constructor\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName - Default Assembly File Name\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAppDomain - Second Appdomain Name.\par
\tab\par
\tab Paste the skeleton code into the code window.\par
\b\f0\par
\b0\par
\cf2\f1 using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\cf2 using\cf0  System.Reflection;\par
\cf2 using\cf0  System.Windows.Forms;\par
\par
\cf2 namespace\cf0  MySpace\par
\{\par
\tab\cf2 public\cf0  \cf2 class\cf0  \cf1 Proxy:\cf0 BaseInterface.\cf1 IBaseInterface\par
\cf0\tab\{\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAppDomain\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  AppDomainName)\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName, \cf2 string\cf0  AppDomainName,\cf2 string\cf0  CurrentType)\par
\tab\tab\{\par
\tab\tab\}\par
\par
\cf2         \tab #region\cf0  BaseInterface Members\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReturnBaseValue()\par
\tab\tab\{\}\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value)\par
\tab\tab\{\}\par
\par
\cf2\tab\tab #endregion\par
\cf0\tab\}\par
\}\par
\b\f0\tab Project  3) Beta Assembly - \b0 The first version of the assembly.\b\par
\par
\b0\tab\tab Name\tab\tab\tab =  \tab Assembly v1.0.\par
\tab\tab Assembly Version\tab =\tab 1.0.0.0\par
\f1\tab\tab References\tab\tab = \tab Solution.BaseInterface.\par
\f0\tab\tab Debug compile path \tab = \tab "..\\..\\CodeProject - Unload.Net Assembly\\CodeProject - Unload.Net Assembly\\bin\\Debug\\". \par
\tab\tab\tab\tab\tab\tab (This is for making the assemblies comes under main executable path.)\par
\cf2\f1\par
\tab\tab\cf0 rename Class1.cs to  \cf1 ClassLibrary.cs\cf0 .\par
\tab\tab\cf6\b ClassLibrary.cs\cf1  - \cf6\b0 Exposes methods that is Implemented from referenced Interface \cf0 BaseInterface.\cf1 IBaseInterface\par
\cf2\par
\cf0\tab\tab Paste the code to the Code Window.\par
\cf2\par
using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\par
\cf2 namespace\cf0  MyAssembly\par
\{\par
    \cf2 public\cf0  \cf2 class\cf0  \cf1 ClassLibrary\cf0  : BaseInterface.\cf1 IBaseInterface\par
\cf0     \{\par
\cf2\tab\tab #region\cf0  BaseInterface Members\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReturnBaseValue()\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value)\par
\tab\tab\{\par
\tab\tab\}\par
\par
\cf2\tab\tab #endregion\par
\cf0\tab\}\par
\}\par
\par
\b\f0\tab Project  4) Final Assembly \b0 - The Next version of the assembly.\b\par
\par
\b0\tab\tab Name\tab\tab\tab =  \tab Assembly v2.0.\par
\tab\tab Assembly Version\tab =\tab 2.0.0.0\par
\f1\tab\tab References\tab\tab = \tab Solution.BaseInterface.\par
\f0\tab\tab Debug compile path \tab = \tab "..\\..\\CodeProject - Unload.Net Assembly\\CodeProject - Unload.Net Assembly\\bin\\Debug\\". \par
\tab\tab\tab\tab\tab\tab (This is for making the assemblies comes under main executable path.)\par
\f1\tab\tab Rename Class1.cs to  \cf1 ClassLibrary.cs\cf0 .\par
\tab\tab\cf6\b ClassLibrary.cs\cf1  - \cf6\b0 Exposes methods that is Implemented from referenced Interface \cf0 BaseInterface.\cf1 IBaseInterface\par
\cf2\par
\cf0\tab\tab Paste the code to the Code Window.\par
\par
\cf2 using\cf0  System;\par
\cf2 using\cf0  System.Collections.Generic;\par
\cf2 using\cf0  System.Text;\par
\par
\cf2 namespace\cf0  MyAssembly\par
\{\par
    \cf2 public\cf0  \cf2 class\cf0  \cf1 ClassLibrary\cf0  : BaseInterface.\cf1 IBaseInterface\par
\cf0     \{\par
\cf2\tab\tab #region\cf0  BaseInterface Members\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReturnBaseValue()\par
\tab\tab\{\par
\tab\tab\}\par
\par
\tab\tab\cf2 public\cf0  \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value)\par
\tab\tab\{\par
\tab\tab\}\par
\par
\cf2\tab\tab #endregion\par
\cf0\tab\}\par
\}\par
\f0\par
\b Step 4: \b0 Final Construction.\par
\par
\tab All the basic structures have been created and now we can proceed to real coding. I am starting from Basic Library into which the busuness logic is to be integrated and serves the core purpose of the application.\par
\b\par
Project  1) Beta Assembly. \par
\tab\b0\par
\tab First thing we have to do is to make Class instance capable of crossing the application boundaries. For this the primary requirement is to inherit the class from \cf1\b\f1 MarshalByRefObject\b0  \cf0\f0 BaseClass. Also we have to mark the class as \b\f1 [\cf1 Serializable\cf0 ]\b0 . To complete the implementation we have to write functionalities inside both methods. Insert the following code inside \b ReturnBaseValue()\par
\par
\b0     \tab\cf2 return\cf0  \cf4 "Value=Assembly Version 1.0"\cf0 ;\par
\par
and insert the code\par
\par
\cf2\tab return\cf0  ReverseString(Value); \par
\par
into the method \b ReverseValue(\cf2 string\cf0  Value)\par
\par
\b0 Then Add the following code under the \b #endregion.\b0\par
\par
\cf2\tab private\cf0  \cf2 string\cf0  ReverseString(\cf2 string\cf0  Value)\par
        \{\par
            \cf1 StringBuilder\cf0  tmp = \cf2 new\cf0  \cf1 StringBuilder\cf0 ();\par
            \cf3 //the actual requirement is >=0. intentionaly made an error in alggoritum to make an error.\par
\cf0             \cf2 for\cf0  (\cf2 int\cf0  i = Value.Length - 1; i > 1; i--)\par
            \{\par
                tmp.Append(Value.Substring(i, 1));\par
            \}\par
            \cf2 return\cf0  tmp.ToString();\par
        \}\b\par
\b0\par
\b\f0 Project  2) Final Assembly. \par
\b0\f1\tab\par
\tab Just like above project\f0  inherit the class from \cf1\b\f1 MarshalByRefObject\b0  \cf0\f0 BaseClass and mark the class as \b\f1 [\cf1 Serializable\cf0 ]\b0 . Then insert the following code inside \b ReturnBaseValue()\par
\par
\b0     \tab\cf2 return\cf0  \cf4 "Value=Assembly Version 2.0"\cf0 ;\par
\par
and insert the code\par
\par
\cf2\tab return\cf0  ReverseString(Value);\par
\par
into the method \b ReverseValue(\cf2 string\cf0  Value)\par
\par
\b0 Then Add the following code under the \b #endregion.\b0\par
\par
 \tab\cf2 private\cf0  \cf2 string\cf0  ReverseString(\cf2 string\cf0  Value)\par
        \{\par
            \cf1 StringBuilder\cf0  tmp = \cf2 new\cf0  \cf1 StringBuilder\cf0 ();\par
            \cf2 for\cf0  (\cf2 int\cf0  i = Value.Length - 1; i >= 0; i--)\par
            \{\par
                tmp.Append(Value.Substring(i, 1));\par
            \}\par
            \cf2 return\cf0  tmp.ToString();\par
        \}\par
\tab\tab\par
\b\f0 Project 3) Proxy.\par
\b0\tab\par
\tab After finishing the business Logic required for functioning we require the assosiated code should be avilable in the proxy. So I think now we can do with modifying Proxy project. It contains three classes.\par
\par
\b Class AssemblyCore\b0\par
\par
We have already given the value for constant \f1 OriginalAssemblyFileName as \cf4 "DefaultAssembly.dll"\cf0 ;. This File name will be the only Assembly file known to the application.\f0\par
\par
Insert the code \f1 inside property \cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName. which will be the same value always.\par
\f0\par
\f1\tab\cf2 get\cf0  \{ \cf2 return\cf0  OriginalAssemblyFileName; \}\par
\par
\f0 When the object instance is created we require the saving of the active type and replace the currently used Assembly with the specified assembly so that application should be able to refer it. For that insert the following code into constructor \f1  \cf2\b public\cf0  AssemblyCore(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  TypeName)\b0\f0\par
\par
\tab\f1     CurrentType = TypeName;\par
          SetDefaultAssemblyFile(AssemblyFileName);\tab\par
\par
\cf6 This function \cf0\b SetDefaultAssemblyFile\b0  \cf6 replaces the currently used Assembly with the specified Assemblyfile. It also saves an instance of newly created assembly file into _DefaultAssemblyFile and saves the original name of assembly.\par
\cf0\f0 Paste this code in the method \cf2\f1 public\cf0  \cf2 bool\cf0  SetDefaultAssemblyFile(\cf2 string\cf0  AssemblyFileName)\f0\par
\par
\f1            \cf2 try\par
\cf0             \{\par
                \cf3 //saves the original file name.\par
\cf0                 _activeAssemblyFile = AssemblyFileName;\par
                \cf1 File\cf0 .Copy(AssemblyFileName, OriginalAssemblyFileName, \cf2 true\cf0 );\par
                _DefaultAssemblyFile = \cf2 new\cf0  \cf1 FileInfo\cf0 (OriginalAssemblyFileName);\par
\tab\tab\tab\tab\cf2 return\cf0  \cf2 true\cf0 ;\par
            \}\par
            \cf2 catch\cf0 (\cf1 Exception\cf0  Err)\par
            \{\par
                \cf1 MessageBox\cf0 .Show(\cf4 "An Error Occured. Versioning Failed. Details : "\cf0  + Err.Message);\par
\tab\tab\tab\tab\cf2 return\cf0  \cf2 false\cf0 ;\par
            \}\par
\f0\par
\cf5\f1\par
\cf6\b Class AppDomainCore\cf5\b0\par
\cf0\f0\tab\par
Insert the following code inside the constructor \cf2\f1 public\cf0  AppDomainCore(\cf2 string\cf0  AppDoaminName)\par
\par
\tab\tab _DefaultAppdomainName = AppDoaminName;\par
            LoadAppDomain();\par
\par
\tab This will Assigne the Active Appdomain name into the property \b DefaultAppDomain \b0 and calls LoadAppDomain() function to create a new Appdomain. Paste the code below into the bottom of the class. Here we are using AppdomainSetup Class to create a new AppDomain. SetShadowCopyFiles() functino enables the application to copy the assembly to another location and load it from there thus releasing the origianl Assembly from locking out.\par
\par
\cf2\tab private\cf0  \cf2 bool\cf0  LoadAppDomain()\par
        \{\par
            \cf1 AppDomainSetup\cf0  ads = \cf2 new\cf0  \cf1 AppDomainSetup\cf0 ();\par
\tab\tab _DefaultAppDomain = \cf1 AppDomain\cf0 .CreateDomain(DefaultAppdomainName, \cf2 null\cf0 , ads);\par
            _DefaultAppDomain.SetShadowCopyFiles();\par
\tab\tab\cf2 return\cf0  \cf2 true\cf0 ;\par
        \}\par
\par
\tab The next step is an optional component. It is not actaully required in this scenario as the unloading of second appdomain is handled automaticaly by GC upon creation of new instance of Proxy object. Paste the code below to bottom line of class. This function is required if you want to unload an appdomain explicitly. Also the call in destrutor is not required as in normal cases the GC will be clearing the contents.\par
\par
\cf2\tab private\cf0  \cf2 bool\cf0  ClearAppDomain()\par
        \{\par
\tab\tab\tab\cf2 try\par
\cf0\tab\tab\tab\{\par
\tab\tab\tab\tab\cf1 AppDomain\cf0 .Unload(DefaultAppDomain);\par
\tab\tab\tab\tab _DefaultAppDomain = \cf2 null\cf0 ;\par
\tab\tab\tab\tab\cf2 return\cf0  \cf2 true\cf0 ;\par
\tab\tab\tab\}\par
\tab\tab\tab\cf2 catch\par
\cf0\tab\tab\tab\{\par
\tab\tab\tab\tab\cf2 return\cf0  \cf2 false\cf0 ;\par
\tab\tab\tab\}\par
        \}\par
\par
\tab\tab ~AppDomainCore()\par
\tab\tab\{\par
\tab\tab\tab ClearAppDomain();\par
\tab\tab\}\par
\f0\par
\cf6\b\f1 Class Proxy\cf0\b0\f0\par
\par
\tab Proxy class abstracts the above two classes. It utilizes the AppdomainCore and AssemblyCore classes.We also require the instance of  \cf6\b\f1 IBaseInterface \b0 to get the local proxy of the business entities.\cf1  \cf6 For these functionalities p\cf0\f0 aste the code below in the begining of the class.\par
\cf3\f1\par
\cf0\tab\tab\cf1 AppDomainCore\cf0  _appDomainController;\par
\tab\tab\cf1 AssemblyCore\cf0  _assemblyController;\par
\tab\tab BaseInterface.\cf1 IBaseInterface\cf0  _proxy;\par
\par
The Proxy exposes two properties to user for enabling it's functionality paste the following code in the method \cf2 public\cf0  \cf2 string\cf0  DefaultAppDomain\par
\cf2\tab\tab\par
\tab\tab get\cf0  \{ \cf2 return\cf0  _appDomainController.DefaultAppdomainName; \}\par
\par
and the following code in \cf2 public\cf0  \cf2 string\cf0  DefaultAssemblyFileName\par
\par
\tab\tab  \cf2 get\cf0  \{ \cf2 return\cf0  _assemblyController.ActiveAssemblyFile; \}\par
\par
Next step is to define the constuctor. Put the code beloew in \cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName,\cf2 string\cf0  AppDomainName)\par
\par
\tab\tab Init(AssemblyFileName, AppDomainName, \cf4 "MyAssembly.ClassLibrary"\cf0 );\par
\par
and code\par
\par
\cf2\tab\tab public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName, \cf2 string\cf0  AppDomainName,\cf2 string\cf0  CurrentType)\par
\par
into overloaded Constructor \cf2 public\cf0  Proxy(\cf2 string\cf0  AssemblyFileName, \cf2 string\cf0  AppDomainName,\cf2 string\cf0  CurrentType)\par
\par
These constructors are calling into a private method Init which we can find here.\par
\par
\tab\tab\cf2 private\cf0  \cf2 bool\cf0  Init(\cf2 string\cf0  AssemblyFileName, \cf2 string\cf0  AppDomainName, \cf2 string\cf0  CurrentType)\par
\tab\tab\{\par
\tab             _assemblyController = \cf2 new\cf0  \cf1 AssemblyCore\cf0 (AssemblyFileName, CurrentType);\par
\tab\tab\tab _appDomainController = \cf2 new\cf0  \cf1 AppDomainCore\cf0 (AppDomainName);\par
\tab\tab\tab\cf2 return\cf0  \cf2 true\cf0 ;\par
\tab\tab\}\par
\par
Init function initialises the two objects created inside the class.\par
\par
\par
Now the main task is to complete implementation of the interfaces with proper functionalities. For this paste the code below into method \cf2 public\cf0  \cf2 string\cf0  ReturnBaseValue()\par
\par
            _proxy = (BaseInterface.\cf1 IBaseInterface\cf0 )_appDomainController.DefaultAppDomain.\par
                CreateInstanceFromAndUnwrap(_assemblyController.DefaultAssemblyFileName,\par
                _assemblyController.CurrentType);\par
\tab\tab\tab\cf2 if\cf0  (_proxy != \cf2 null\cf0 )\par
            \{\par
                \cf2 return\cf0  _proxy.ReturnBaseValue();\par
            \}\par
            \cf2 return\cf0  \cf2 null\cf0 ;\par
\par
This method CreateInstanceFromAndUnwrap creates and unwrap a remote proxy instance. This object is casted to Interfacetype to assign into _proxy. The method below also can be done in the similar way but I have adopted another way to do this using reflection. Paste the code into method \cf2 public\cf0  \cf2 string\cf0  ReverseValue(\cf2 string\cf0  Value)\par
\par
\cf2\tab\tab return\cf0  ((\cf2 string\cf0 )GetReversedString(\cf4 "ReverseString"\cf0 , \cf2 new\cf0  \cf2 object\cf0 [] \{ Value \}));\par
\par
and the below method GetReversedString(..) under the function.\par
\par
\cf2\tab\tab private\cf0  \cf2 object\cf0  GetReversedString(\cf2 string\cf0  MethodName,\cf2 object\cf0 [] Arguments)\par
\tab         \{\par
      \tab       \cf2 object\cf0  proxy = (BaseInterface.\cf1 IBaseInterface\cf0 )\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab _appDomainController.DefaultAppDomain.CreateInstanceFromAndUnwrap\par
\tab                 (_assemblyController.DefaultAssemblyFileName, _assemblyController.CurrentType);\par
      \tab       \cf2 if\cf0  (proxy != \cf2 null\cf0 )\par
            \tab\{\par
\tab                 \cf1 MethodInfo\cf0  mi = proxy.GetType().GetMethod(MethodName, \cf1 BindingFlags\cf0 .DeclaredOnly | \par
      \tab               \cf1 BindingFlags\cf0 .NonPublic | \cf1 BindingFlags\cf0 .Instance);\par
            \tab     \cf2 if\cf0  (mi != \cf2 null\cf0 )\par
\tab                 \{\par
      \tab               \cf2 object\cf0  rv = mi.Invoke(proxy, Arguments);\par
            \tab         \cf2 return\cf0  rv;\par
\tab                 \}\par
      \tab           \cf2 else\par
\cf0             \tab     \{\par
\tab                     \cf1 MessageBox\cf0 .Show(\cf4 "Oops. Such a method not found...!"\cf0 , \cf4 ".Net Reflection"\cf0 , \par
      \tab                   \cf1 MessageBoxButtons\cf0 .OK, \cf1 MessageBoxIcon\cf0 .Error);\par
\tab                 \}\par
      \tab       \}\par
            \tab\cf2 return\cf0  \cf2 null\cf0 ;\par
\tab       \}\par
The above alternative will be useful if we don't have an Interface exposed or in worst case senario the method signature is not available at designtime. instead of calling the method from the interface instance here I am querying the object instance for the method signature and invoking it.\par
\par
\b Project 4) Basic interface.\par
\tab\b0 Here Nothing is left. Everything is completed in first phase itself.\par
\par
\b Project 5) Main Application.\par
\par
\b0\tab Finally after all these classes are defined and implemented we have to intergrate it into the main Windows Application for making it working. For this first thing thing we have to do is to add a reference to both \b Proxy \b0 and \b BaseInterface \b0 projects.Add the code to the top of the Form1 code window\par
\par
\tab\tab\cf2 using\cf0  MySpace;\tab\par
\par
Paste the code in the top of Class Form1 to create an instance of \b Myspace.Proxy\b0  inside the \b Form1\b0 .\par
\par
\par
\cf1\tab\tab Proxy\cf0  DefaultProxy;\par
\par
In the Form1_Load do the following coding.\par
\par
\tab\tab DefaultProxy = \cf2 new\cf0  \cf1 Proxy\cf0 (\cf4 "Assembly v1.0.dll"\cf0 , \cf4 "Domain1"\cf0 );\par
            lblCurrentAppDomain.Text = DefaultProxy.DefaultAppDomain;\par
            lblCurrentAssembly.Text = DefaultProxy.DefaultAssemblyFileName;\par
            lblMainAppDomian.Text = \cf1 AppDomain\cf0 .CurrentDomain.FriendlyName;\par
\par
In the Click Event of radioAseembly1 paste the following code.\par
\par
\tab\tab DefaultProxy = \cf2 new\cf0  \cf1 Proxy\cf0 (\cf4 "Assembly v1.0.dll"\cf0 , \cf4 "Domain1"\cf0 );\par
            lblCurrentAppDomain.Text = DefaultProxy.DefaultAppDomain;\par
            lblCurrentAssembly.Text = DefaultProxy.DefaultAssemblyFileName;\par
            lblMainAppDomian.Text = \cf1 AppDomain\cf0 .CurrentDomain.FriendlyName;\par
\par
and the User experience elements\par
\tab\tab\par
\tab\tab\cf3 //Extras\par
\cf0             errorProvider1.BlinkStyle = \cf1 ErrorBlinkStyle\cf0 .AlwaysBlink;\par
            errorProvider1.SetError(radioAssembly2, \cf4 ""\cf0 );\par
            errorProvider1.SetError(radioAssembly1,\cf4 "This Dll is a Beta Version. It won't reverse the string properly"\cf0 );\par
\par
\par
Then In the Click Event of radioAseembly2 paste the following code.\par
\par
\tab\tab DefaultProxy = \cf2 new\cf0  \cf1 Proxy\cf0 (\cf4 "Assembly v2.0.dll"\cf0 , \cf4 "Domain2"\cf0 );\par
            lblCurrentAppDomain.Text = DefaultProxy.DefaultAppDomain;\par
            lblCurrentAssembly.Text = DefaultProxy.DefaultAssemblyFileName;\par
            lblMainAppDomian.Text = \cf1 AppDomain\cf0 .CurrentDomain.FriendlyName;\par
\par
and the User experience elements\par
\par
\tab\tab errorProvider1.BlinkStyle = \cf1 ErrorBlinkStyle\cf0 .AlwaysBlink;\par
            errorProvider1.SetError(radioAssembly1, \cf4 ""\cf0 );\par
            errorProvider1.SetError(radioAssembly2,\cf4 "This Dll is the Final Version"\cf0 );\par
\par
\f0 All the staments above creates a new instance of the proxy which internally destroys the Exisiting Appdomain, replaces the Assembly file with the new one and loads that into the application.\par
\par
\par
For utilising the Business functionalities implemented in proxy we have to use click events in buttons.\par
\par
in the click event in \b btnCalculate\b0  do the following code.\par
\par
\tab\tab\f1 txtReverseData.Text =  DefaultProxy.ReverseValue(txtReverseData.Text);\par
\par
\f0 in the click event in \b\f1 btnGetValue\b0\f0  do the following code.\par
\par
\tab\tab\f1 txtReturnedData.Text = DefaultProxy.ReturnBaseValue();\par
\par
\b\f0\fs24 Running The Application:\par
\b0\fs20\par
Now in order to make ensure proper working of the application comple it using Rebuild Solution option. Now  run the application.\par
\par
\tab By default the assembly version one will be loaded. You should be able to see the information like Current Assembly, Current Appdomain, Main Appdomain etc in the window. Upon clicking the Reverse the value in the text will be reversed. But because of the bug each time the length will reduce. We can get the Version of assembly as 1 upon clicking the button GetValue.\par
\par
\tab Now click upon the radio button Load Assembly V 2.0 to load the final version. You should be able to see errorprovider's message in respective radio buttons.\par
\par
\tab Now the application is loaded with the second version of the assembly which has the bug fixed. So now you will get the Reversed value properly. and now we can get the Version of assembly as 2 upon clicking the button GetValue.\par
\par
\b\fs28 Future Plans:\par
\par
\b0\fs20\tab Because I am currently working upon .Net 3.0 and Composite UI Application Block. I am trying to implement this feature into CAB Applications. I have already created a sample which can load a UI module upon a button click or any UI event. But The same problem with .Net 2.0 Applications exisits there. So I am now proceeding with finding some way to Unload a Dynamically loaded Module from a CAB Application. This may take some time I think as I am busy with a lot of things, but you can expect one article with this update.\par
\b\fs28\par
\b0\fs20\par
\par
\par
}
 